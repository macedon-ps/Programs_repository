<resources>
    <string name="app_name">MyAndroidHandbook</string>
    <string name="navigation_drawer_open">Open navigation drawer</string>
    <string name="navigation_drawer_close">Close navigation drawer</string>
    <string name="nav_header_title">Справочник по Android</string>
    <string name="nav_header_subtitle">Andrey Kazanchan, v.1</string>
    <string name="nav_header_desc">Navigation header</string>
    <string name="action_settings">Settings</string>

    <string name="menu_layouts">Layouts (Макеты)</string>
    <string name="menu_views">Views (Элементы)</string>
    <string name="menu_codes">Java codes (Код)</string>
    <string name="menu_tips">Useful tips (Советы)</string>
    <string name="menu_theory">Some theory (Теория)</string>
    <string name="text_view_layout1">
        FrameLayout
        FrameLayout является самым простым типом разметки. Обычно это пустое пространство на экране, которое можно заполнить только дочерними объектами View или ViewGroup. Все дочерние элементы FrameLayout прикрепляются к верхнему левому углу экрана.
        В разметке FrameLayout нельзя определить различное местоположение для дочернего объекта. Последующие дочерние объекты View будут просто рисоваться поверх предыдущих компонентов, частично или полностью затеняя их, если находящийся сверху объект непрозрачен, поэтому единственный дочерний элемент для FrameLayout обычно растянут до размеров родительского контейнера и имеет атрибуты:

        android:layout_width="match_parent"
        android:layout_height="match_parent"

        Также можно использовать свойства Gravity для управления порядком размещения.
        FrameLayout можно использовать для интересного эффекта, когда верхняя часть (TextView) остаётся неизменной, а основной контент прокручивается.
    </string>
    <string name="text_view_layout2">
        ConstraintLayout
        ConstraintLayout представляет новый тип контейнеров, который является развитием RelativeLayout и позволяет создавать гибкие и масштабируемые интерфейсы.
        Начиная с версии Android Studio 2.3 ConstraintLayout был добавлен в список стандартных компонентов и даже является контейнером, который используется в файлах layout по умолчанию. Однако если вы используете Android Studio 2.2 или ниже, то в этом случае функциональность ConstraintLayout надо дополнительно добавлять.
        Для позиционирования элемента внутри ConstraintLayout необходимо указать ограничения (constraints). Есть несколько типов ограничений. В частности, для установки позиции относительно определенного элемента испльзуются следующие ограничения:
        layout_constraintLeft_toLeftOf: левая граница позиционируется относительно левой границы другого элемента
        layout_constraintLeft_toRightOf: левая граница позиционируется относительно правой границы другого элемента
        layout_constraintRight_toLeftOf: правая граница позиционируется относительно левой границы другого элемента
        layout_constraintRight_toRightOf: правая граница позиционируется относительно правой границы другого элемента
        layout_constraintTop_toTopOf: верхняя граница позиционируется относительно верхней границы другого элемента
        layout_constraintBottom_toBottomOf: нижняя граница позиционируется относительно нижней границы другого элемента
        layout_constraintBaseline_toBaselineOf: базовая линия позиционируется относительно базовой линии другого элемента
        layout_constraintTop_toBottomOf: верхняя граница позиционируется относительно нижней границы другого элемента
        layout_constraintBottom_toTopOf: нижняя граница позиционируется относительно верхней границы другого элемента
        layout_constraintStart_toEndOf: аналог layout_constraintLeft_toRightOf
        layout_constraintStart_toStartOf: аналог layout_constraintLeft_toLeftOf
        layout_constraintEnd_toStartOf: аналог layout_constraintRight_toLeftOf
        layout_constraintEnd_toEndOf: аналог layout_constraintRight_toRightOf
        Позиционирования может производиться относительно границ самого контейнера ContentLayout (в этом случае ограничение имеет значение "parent"), либо же относительно любого другого элемента внутри ConstraintLayout, тогда в качестве значения ограничения указывается id этого элемента.
        Чтобы указать отступы от элемента, относительно которого производится позиционирования, применяются следующие атрибуты:
        android:layout_marginLeft: отступ от левой границы
        android:layout_marginRight: отступ от правой границы
        android:layout_marginTop: отступ от верхней границы
        android:layout_marginBottom: отступ от нижней границы
        android:layout_marginStart: отступ от левой границы
        android:layout_marginEnd: отступ от правой границы
    </string>
    <string name="text_view_layout3">
        LinearLayout
        Контейнер LinearLayout представляет объект ViewGroup, который упорядочивает все дочерние элементы в одном направлении: по горизонтали или по вертикали. Все элемены расположены один за другим. Направление разметки указывается с помощью атрибута android:orientation.
        Если, например, ориентация разметки вертикальная (android:orientation="vertical"), то все элементы располагаются в столбик - по одному элементу на каждой строке. Если ориентация горизонтальная (android:orientation="horizontal"), то элементы располагаются в одну строку.
        Если для LinearLayout указать атрибут android:orientation="vertical", то элементы будут размещены по вертикали, а если указать атрибут android:orientation="horizontal", то - по горизонтали.
        LinearLayout поддерживает такое свойство, как вес элемента, которое передается атрибутом android:layout_weight. Это свойство принимает значение, указывающее, какую часть оставшегося свободного места контейнера по отношению к другим объектам займет данный элемент. Например, если один элемент у нас будет иметь для свойства android:layout_weight значение 2, а другой - значение 1, то в сумме они дадут 3, поэтому первый элемент будет занимать 2/3 оставшегося пространства, а второй - 1/3.
        Если все элементы имеют значение android:layout_weight="1", то все эти элементы будут равномерно распределены по всей площади контейнера
    </string>
    <string name="text_view_layout4">
        RelativeLayout
        RelativeLayout представляет объект ViewGroup, который располагает дочерние элементы относительно позиции других дочерних элементов разметки или относительно области самой разметки RelativeLayout. Используя относительное позиционирование, мы можем установить элемент по правому краю или в центре или иным способом, который предоставляет данный контейнер. Для установки элемента в файле xml мы можем применять следующие атрибуты:
        android:layout_above: располагает элемент над элементом с указанным Id
        android:layout_below: располагает элемент под элементом с указанным Id
        android:layout_toLeftOf: располагается слева от элемента с указанным Id
        android:layout_toRightOf: располагается справа от элемента с указанным Id
        android:layout_alignBottom: выравнивает элемент по нижней границе другого элемента с указанным id
        android:layout_alignLeft: выравнивает элемент по левой границе другого элемента с указанным Id
        android:layout_alignRight: выравнивает элемент по правой границе другого элемента с указанным Id
        android:layout_alignTop: выравнивает элемент по верхней границе другого элемента с указанным Id
        android:layout_alignBaseline: выравнивает базовую линию элемента по базовой линии другого элемента с указанным Id
        android:layout_alignParentBottom: если атрибут имеет значение true, то элемент прижимается к нижней границе контейнера
        android:layout_alignParentRight: если атрибут имеет значение true, то элемент прижимается к правому краю контейнера
        android:layout_alignParentLeft: если атрибут имеет значение true, то элемент прижимается к левому краю контейнера
        android:layout_alignParentTop: если атрибут имеет значение true, то элемент прижимается к верхней границе контейнера
        android:layout_centerInParent: если атрибут имеет значение true, то элемент располагается по центру родительского контейнера
        android:layout_centerHorizontal: при значении true выравнивает элемент по центру по горизонтали
        android:layout_centerVertical: при значении true выравнивает элемент по центру по вертикали
        Для позиционирования относительно другого элемента, нам надо указать id этого элемента.
        Чтобы задать положение элемента в контейнере, применяется класс RelativeLayout.LayoutParams. Через конструктор устанавливаются значения для ширины и высоты. Например, у элемента EditText для ширины устанавливается значение MATCH_PARENT, а для высоты - WRAP_CONTENT.
        С помощью метода addRule() мы можем добавлять дополнительные правила для позиционирования элемента. Этот метод в качестве параметра принимает числовую константу, которая представляет параметр позиционирования и которая аналогична атрибуту. Например, атрибуту android:layout_centerInParent будет соответствовать константа CENTER_IN_PARENT, а атрибуту android:layout_alignRight константа ALIGN_RIGHT.
        Стоит отметить, что в целях упрощения кода для установки id у EditText вызывается метод generateViewId();, который позволяет программно сгенерировать id для элемента управления.
        Затем установленный id передается в качестве второго параметра в метод addRule при установке правил для кнопки:
        buttonParams.addRule(RelativeLayout.BELOW, editText.getId());
        Тем самым мы указываем относительно какого элемента надо задать расположение.
    </string>
    <string name="text_view_layout5">
        TableLayout
        Контейнер TableLayout структурирует элементы управления по столбцам и строкам. Определим в файле activity_main.xml элемент TableLayout, который будет включать две строки и два столбца:
        Используя элемент TableRow, мы создаем отдельную строку. Как разметка узнает сколько столбцов надо создать? Android находит строку с максимальным количеством виджетов одного уровня, и это количество будет означать количество столбцов. Например, в данном случае у нас определены две строки и в каждой по два элемента. Если бы в какой-нибудь из них было бы три виджета, то соответственно столбцов было бы также три, даже если в другой строке осталось бы два виджета.Причем элемент TableRow наследуется от класса LinearLayout, поэтому мы можем к нему применять тот же функционал, что и к LinearLayout. В частности, для определения пространства для элементов в строке используется атрибут android:layout_weight.
        Если какой-то элемент должен быть растянут на ряд столбцов, то мы можем растянуть его с помощью атрибута layout_span, который указывает на какое количество столбцов надо растянуть элемент:
    </string>
    <string name="text_view_layout6">
        GridLayout
        GridLayout представляет еще один контейнер, который позволяет создавать табличные представления. GridLayout состоит из коллекции строк, каждая из которых состоит из отдельных ячеек:
<!--        <GridLayout xmlns:android="http://schemas.android.com/apk/res/android"-->
<!--            android:layout_width="match_parent"-->
<!--            android:layout_height="match_parent"-->
<!--            android:rowCount="3"-->
<!--            android:columnCount="3">-->
<!--            <Button android:text="1" />-->
<!--            <Button android:text="2" />-->
<!--            <Button android:text="3" />-->
<!--            <Button android:text="4" />-->
<!--            <Button android:text="5" />-->
<!--            <Button android:text="6" />-->
<!--            <Button android:text="7" />-->
<!--            <Button android:text="8" />-->
<!--            <Button android:text="9" />-->
<!--        </GridLayout>-->
        С помощью атрибутов android:rowCount и android:columnCount устанавливается число строк и столбцов соответственно. Так, в данном случае устанавливаем 3 строки и 3 столбца. GridLayout автоматически может позиционировать вложенные элементы управления по строкам. Так, в нашем случае первая кнопка попадает в первую ячейку (первая строка первый столбец), вторая кнопка - во вторую ячейку и так далее.
        При этом ширина столбцов устанавливается автоматически по ширине самого широкого элемента.
        Однако мы можем явно задать номер столбца и строки для определенного элемента, а при необходимости растянуть на несколько столбцов или строк. Для этого мы можем применять следующие атрибуты:
        android:layout_column: номер столбца (отсчет идет от нуля)
        android:layout_row: номер строки
        android:layout_columnSpan: количество столбцов, на которые растягивается элемент
        android:layout_rowSpan: количество строк, на которые растягивается элемент
    </string>
    <string name="text_view_view1">
        TextView
        Для простого вывода текста на экран предназначен элемент TextView. Он просто отображает текст без возможности его редактирования. Некоторые его основные атрибуты:
        android:text: устанавливает текст элемента
        android:textSize: устанавливает высоту текста, в качестве единиц измерения для указания высоты используются sp
        android:background: задает фоновый цвет элемента в виде цвета в шестнадцатиричной записи или в виде цветового ресурса
        android:textColor: задает цвет текста
        android:textAllCaps: при значении true делает все символы в тексте заглавными
        android:textDirection: устанавливает направление текста. По умолчанию используется направление слева направо, но с помощью значения rtl можно установить направление справо налево
        android:textAlignment: задает выравнивание текста. Может принимать следующие значения:
        center: выравнивание по центру
        textStart: по левому краю
        textEnd: по правому краю
        viewStart: по левому краю
        viewEnd: по правому краю
        android:fontFamily: устанавливает тип шрифта. Может принимать следующие значения:
        monospace
        serif-monospace
        sans-serif
        sans-serif-condensed
        sans-serif-smallcaps
        sans-serif-light
        casual
        cursive
    </string>
    <string name="text_view_view2">
        ImageView
        Компонент ImageView предназначен для отображения изображений. Находится в разделе Widgets.
        Для загрузки изображения в XML-файле используется атрибут android:src, в последнее время чаще используется атрибут app:srcCompat.
        ImageView является базовым элементом-контейнером для использования графики. Можно загружать изображения из разных источников, например, из ресурсов программы, контент-провайдеров. В классе ImageView существует несколько методов для загрузки изображений:
        setImageResource(int resId) — загружает изображение по идентификатору ресурса
        setImageBitmap(Bitmap bitmap) — загружает растровое изображение
        setImageDrawable(Drawable drawable) - загружает готовое изображение
        setImageURI(Uri uri) — загружает изображение по его URI
    </string>
    <string name="text_view_view3">
        Button
        Одним из часто используемых элементов являются кнопки, которые представлены классом android.widget.Button. Ключевой особенностью кнопок является возможность взаимодействия с пользователем через нажатия.
        Некоторые ключевые атрибуты, которые можно задать у кнопок:
        text: задает текст на кнопке
        textColor: задает цвет текста на кнопке
        background: задает фоновый цвет кнопки
        textAllCaps: при значении true устанавливает текст в верхнем регистре. По умолчанию как раз и применяется значение true
        onClick: задает обработчик нажатия кнопки
        При создании метода обработки нажатия следует учитывать следующие моменты:
        Метод должен объявляться с модификатором public
        Должен возвращать значение void
        В качестве параметра принимать объект View. Этот объект View и представляет собой нажатую кнопку
    </string>
    <string name="text_view_view4">
        CheckBox
        Компонент CheckBox является флажком, с помощью которого пользователь может отметить (поставить галочку) определенную опцию. Очень часто флажки используются в настройках, когда нужно выборочно выбрать определенные пункты, необходимые для комфортной работы пользователю.
        Компонент находится в группе Buttons
        Для управления состояниями флажка используйте методы setChecked() или togglе(). Чтобы узнать текущее состояние флажка, вызовите свойство isChecked.
        Если потребуется задействовать специфическую логику, в соответствии с которой флажок будет включаться или выключаться, зарегистрируйте событие, вызвав setOnCheckedChangeListener() с реализацией интерфейса OnCheckedChangeListener. Затем будет нужно реализовать метод onCheckedChanged(), который будет вызываться при изменении состояния флажка.
        Для экспериментов воспользуемся программой «Счетчик ворон», которую писали при изучении щелчка кнопки.
        Как вы помните, в программе была кнопка и текстовое поле. Добавим еще два элемента CheckBox, а также четыре текстовые метки TextView. Нам нужно постараться, чтобы элементы были аккуратно сгруппированы. Для этой цели воспользуемся вложенными компоновками LinearLayout. Заодно применим интересный прием - мы не будем использовать текст у флажков CheckBox, а воспользуемся текстовыми метками с разными размерами шрифтов. Верхняя метка с крупным шрифтом будет указывать на основную функциональность флажка, а нижняя метка с мелким шрифтом будет использоваться в качестве своеобразной подсказки, в которой содержится дополнительная информация для пользователя.
    </string>
    <string name="text_view_view5">
        Switch
        Switch - ещё один вид переключателей, который появился в Android 4.0 (API 14). Находится в разделах Commons и Buttons. Фактически, это замена немного устаревшего ToggleButton. В новых проектах лучше использовать Switch.
        Компонент используется в том случае, когда нужно переключиться на противоположное состояние - да/нет, вкл./выкл., открыть/закрыть. В реальной жизни это выглядит следующим образом.
        Если нужна поддержка старых устройств (7+), то можно использовать SwitchCompat из библиотеки совместимости.
        Компонент представляет собой полоску с двумя состояниями и сопровождающим текстом. Переключиться можно сдвиганием ползунка или касанием экрана в области компонента (не только на самом ползунке, но и на сопровождающем тексте).
        По умолчанию виджет находится в выключенном состоянии. Чтобы установить его в включенном состоянии на этапе разработки, используйте атрибут android:checked="true".
        Сопровождающий текст задаётся в атрибуте android:text. А текст на самом переключателе задаётся при помощи атрибутов android:textOn (методы getTextOn() и setTextOn()) и android:textOff (методы getTextOff() и setTextOff()). Обратите внимание, что сопровождающий текст может быть очень большим и положение самого переключателя относительно этого текста можно регулировать при помощи атрибута android:gravity (смотри пример ниже). Если сопровождающий текст вам не нужен, то не используйте атрибут android:text.
        Момент переключения можно отслеживать при помощи прослушки событий setOnCheckedChangeListener.
    </string>
    <string name="text_view_view6">
        WebView
        WebView — это компонент, который позволяет встраивать веб-страницы в приложения, своеобразный мини-браузер. Находится в разделе Containers.
        В старых версиях Android WebView использовал движок WebKit. В Android 4.4 он стал использовать движок Chromium или Blink. В Android 5 появилось отдельное приложение System WebView, которое можно скачать из Play Market. Такое разделение позволило обновлять движок без обновления системы. На этом приключения не закончились. В Android 7.0 уже используется движок Chrome, а если этого браузера на устройстве нет, то используется System WebView. Подобные выкрутасы не прошли даром, программисты часто жалуются, что какой-то кусок кода не работает. Приходится проверять работу на разных устройствах. Общий принцип работы сохранился.
        Надеюсь, вы уже познакомились с базовым примером по созданию собственного браузера. Рассмотрим дополнительные возможности элемента WebView.
    </string>
    <string name="text_view_codes1">
        Создание всплывающих сообщений (Toast)
        Всплывающее уведомление (Toast Notification) является сообщением, которое появляется на поверхности окна приложения, заполняя необходимое ему количество пространства, требуемого для сообщения. При этом текущая деятельность приложения остаётся работоспособной для пользователя. В течение нескольких секунд сообщение плавно закрывается. Всплывающее уведомление также может быть создано службой, работающей в фоновом режиме. Как правило, всплывающее уведомление используется для показа коротких текстовых сообщений.

        Настройка позиции на экране
        По умолчанию стандартное всплывающее уведомление появляется в нижней части экрана. Изменить место появления уведомления можно с помощью метода setGravity(int, int, int). Метод принимает три параметра:
        стандартная константа для размещения объекта в пределах большего контейнера (например, GRAVITY.CENTER, GRAVITY.TOP и др.);
        смещение по оси X
        смещение по оси YНапример, если вы хотите, чтобы уведомление появилось в центре экрана, то используйте следующий код (до вызова метода show()):
        toast.setGravity(Gravity.CENTER, 0, 0);
        Для вывода в левом верхнем углу.
        toast.setGravity(Gravity.TOP or Gravity.LEFT, 0, 0)
        Если нужно сместить уведомление направо, то просто увеличьте значение второго параметра. Для смещения вниз нужно увеличить значение последнего параметра. Соответственно, для смещения вверх и влево используйте отрицательные значения.
        В файле MainActivity.java:
        Toast toast = Toast.makeText(getApplicationContext(), "Пора покормить кота!", Toast.LENGTH_SHORT);
        toast.show();

        Константы для указания продолжительности показа сообщения
        LENGTH_SHORT — (По умолчанию) показывает текстовое уведомление на короткий промежуток времени;
        LENGTH_LONG — показывает текстовое уведомление в течение длительного периода времени.
        Если покопаться в исходниках Android, то можно найти такие строчки:
        private static final int LONG_DELAY = 3500; // 3.5 seconds
        private static final int SHORT_DELAY = 2000; // 2 seconds
    </string>
    <string name="text_view_codes2">
        Создание меню (Menu)
        Тег menu является корневым узлом файла и определяет меню, состоящее из одного или нескольких элементов item и group.
        Элемент tem представляет объект MenuItem, которой является одним из элементов меню. Этот элемент может содержать внутренний подэлемент menu, с помощью которого создается подменю.
        Элемент item включает следующие атрибуты, которые определяют его внешний вид и поведение:

        android:id: уникальный id элемента меню, который позволяет его опознать при выборе пользователем и найти через поиск ресурса по id
        android:icon: ссылка на ресурс drawable, который задает изображение для элемента (android:icon="@drawable/ic_help")
        android:title: ссылка на ресурс строки, содержащий заголовок элемента. По умолчанию имеет значение "Settings"
        android:orderInCategory: порядок следования элемента в меню

        В файле разметки:
<!--        <?xml version="1.0" encoding="utf-8"?>-->
<!--        <menu xmlns:android="http://schemas.android.com/apk/res/android">-->
<!--    <item-->
<!--        android:id="@+id/action_settings"-->
<!--        android:orderInCategory="1"-->
<!--        android:title="Настройки" />-->
<!--    <item-->
<!--        android:id="@+id/save_settings"-->
<!--        android:orderInCategory="3"-->
<!--        android:title="Сохранить" />-->
<!--    <item-->
<!--        android:id="@+id/open_settings"-->
<!--        android:orderInCategory="2"-->
<!--        android:title="Открыть" />-->
<!--</menu>-->
        В файле MainActivity.java:
        @Override
        public boolean onCreateOptionsMenu(Menu menu) {
            getMenuInflater().inflate(R.menu.main_menu, menu);
            return true;
        }
    </string>
    <string name="text_view_codes3">
        Создание кнопок-переключателей (ToggleButton)
        Компонент ToggleButton по своей функциональности похож на флажок (checkbox) или переключатель (radiobutton) - это кнопка, которая может находиться в одном из двух состояний: активна (On) или неактивна (Off). По умолчанию на кнопке написано "Оn", если она активна, и "Off" - если нет. По внешнему виду это обычная кнопка с декоративной полоской в нижней части, которая подсвечивается в включенном состоянии (имитация LED-индикатора).
        В файле разметки:
<!--        <ToggleButton-->
<!--            android:id="@+id/toggleButton"-->
<!--            android:layout_width="match_parent"-->
<!--            android:layout_height="wrap_content"-->
<!--            android:checked="false"-->
<!--            android:text="ToggleButton"-->
<!--            android:textOff="Не гладить"-->
<!--            android:textOn="Гладить" />-->
        Для создания обработчика события изменения состояния кнопки необходима реализация интерфейса CompoundButton.OnCheckedChangeListener. Интерфейс имеет единственный метод onCheckedChanged(), который необходимо переопределить в нашем классе. При обработке события для определения состояния используется параметр isChecked.
        public class ToggleButtonDemoActivity extends Activity implements OnCheckedChangeListener {
            ToggleButton toogleButton;
            TextView tvInfo;
            @Override
            public void onCreate(Bundle savedInstanceState) {
                super.onCreate(savedInstanceState);
                setContentView(R.layout.main);
                toogleButton = (ToggleButton) findViewById(R.id.toggleButton);
                tvInfo = (TextView) findViewById(R.id.tvInfo);
                toogleButton.setOnCheckedChangeListener(this);
            }
            @Override
            public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
                if (isChecked)
                    tvInfo.setText("Состояние: Включён");
                else
                    tvInfo.setText("Состояние: Выключен");
            }
        }
    </string>
    <string name="text_view_codes4">
        Создание индикаторов прогресса (ProgressBar)
        Компонент ProgressBar (Индикатор прогресса) применяется в тех случаях, когда пользователю нужно показать, что программа не зависла, а выполняет продолжительную работу.
        В файле разметки:
<!--        <ProgressBar-->
<!--            android:id="@+id/progressBar"-->
<!--            android:visibility="invisible"-->
<!--            android:layout_width="wrap_content"-->
<!--            android:layout_height="wrap_content" />-->
        В файле MainActivity.java:
        ProgressBar progressBar = (ProgressBar) findViewById(R.id.progressBar);
        progressBar.setVisibility(ProgressBar.VISIBLE);
        // запускаем длительную операцию
        progressBar.setVisibility(ProgressBar.INVISIBLE);
    </string>
    <string name="text_view_codes5">
        Создание показателя рейтинга (RatingBar)
    В файле разметки -  3 возможных варианта использования:
<!--    <RatingBar-->
<!--        android:id="@+id/ratingBar_indicator"-->
<!--            style="?android:attr/ratingBarStyleIndicator"-->
<!--            android:layout_width="wrap_content"-->
<!--            android:layout_height="wrap_content" />-->

<!--    <RatingBar-->
<!--        android:id="@+id/ratingBar_small"-->
<!--        style="?android:attr/ratingBarStyleSmall"-->
<!--        android:layout_width="wrap_content"-->
<!--        android:layout_height="wrap_content"-->
<!--        android:numStars="10" />-->

<!--    <RatingBar-->
<!--        android:id="@+id/ratingBar_default"-->
<!--        style="?android:attr/ratingBarStyle"-->
<!--        android:layout_width="wrap_content"-->
<!--        android:layout_height="wrap_content" />-->
        В файле MainActivity.java:
        final RatingBar smallRatingBar = (RatingBar) findViewById(R.id.ratingBar_small);
        final RatingBar indicatorRatingBar = (RatingBar) findViewById(R.id.ratingBar_indicator);
        final RatingBar defaultRatingBar = (RatingBar) findViewById(R.id.ratingBar_default);
        defaultRatingBar.setOnRatingBarChangeListener(new RatingBar.OnRatingBarChangeListener() {
        @Override
        public void onRatingChanged(RatingBar ratingBar, float rating,boolean fromUser) {
            smallRatingBar.setRating(rating);
            indicatorRatingBar.setRating(rating);
            Toast.makeText(MainActivity.this, "рейтинг: " + String.valueOf(rating),
            Toast.LENGTH_LONG).show();
            }
        });
    </string>
    <string name="text_view_codes6">
        Создание слайдера (SeekBar)
        SeekBar - это обычный слайдер, когда пользователь может передвигать ползунок пальцем на экране. Ползунок также можно двигать при помощи клавиш-стрелок.
        Компонент SeekBar находится в разделе Widgets и наследуется от класса ProgressBar. В Android Studio 3.0 представлен в двух вариантах: SeekBar и SeekBar (Discrete).
        Для отслеживания перемещения ползунка SeekBar необходимо реализовать интерфейс-слушатель SeekBar.OnSeekBarChangeListener с методами-заглушками:
        onProgressChanged() — уведомляет об изменении положения ползунка;
        onStartTrackingTouch() — уведомляет о том, что пользователь начал перемещать ползунок;
        onStopTrackingTouch() — уведомляет о том, что пользователь закончил перемещать ползунок
        В файле разметки:
<!--        <SeekBar-->
<!--            android:id="@+id/seekBar"-->
<!--            android:layout_width="368dp"-->
<!--            android:layout_height="wrap_content"-->
<!--            android:layout_marginTop="8dp"-->
<!--            android:max="100"-->
<!--            android:progress="3"-->
<!--            app:layout_constraintLeft_toLeftOf="parent"-->
<!--            app:layout_constraintRight_toRightOf="parent"-->
<!--            app:layout_constraintTop_toBottomOf="@+id/textView"/>-->
        В файле MainActivity.java:
        final SeekBar seekBar = (SeekBar)findViewById(R.id.seekBar);
        seekBar.setOnSeekBarChangeListener(this);
        mTextView = (TextView)findViewById(R.id.textView);
        mTextView.setText("0");
        }
        @Override
        public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {
        }
        @Override
        public void onStartTrackingTouch(SeekBar seekBar) {
        }
        @Override
        public void onStopTrackingTouch(SeekBar seekBar) {
        mTextView.setText(String.valueOf(seekBar.getProgress()));
        }
    </string>
    <string name="text_view_tips1">
        Горячие клавиши Android Studio
    Среди большого числа гарячих клавиш выделим следующие:
        ctrl + D          - копировать последнюю строку
        ctrl + shift + /  - закомментировать весь выделенный текст
        ctrl + /          - закомментировать весь выделенный текст построчно
        ctrl + пробел     - вызов всплывающих подсказок
        ctrl + ins        - высвечиваются возможные методы
        ctrl + ЛКМ        - переход по выделенному слову к параметрам и методам
        alt + Enter       - контекст всего; всплывающие подсказки, возможные действия
        alt + F7          - поиск применения выделенного кода в данном приложении
        И много других
    </string>
    <string name="text_view_tips2">
        Автосохранение
        Для того, чтобы установить автосохранение в Android Studio, необходимо нажать на вкладку File, в ней выбрать Settings. Откроется окно настроек Android Studio. В нем нужно выбрать вкладку Appearance And Behavior. Затем выбрать вкладку System Settings. Далее выбираем Synchronization. После этого в окно чекбокса автосохранения (Save file automatically if application is idle for 15 sec) нужно установить переключатель, чтобы установить режим автосохранения приложения.
        Время автосохранения (15 сек) можно регулировать вручную.
    </string>
    <string name="text_view_tips3">
        Установка размера текста
        Для того, чтобы установить размер отображаемого текста кода в Android Studio, необходимо нажать на вкладку File, в ней выбрать Settings. Откроется окно настроек Android Studio. В нем нужно выбрать вкладку Appearance And Behavior. Затем выбрать вкладку Editor. Далее выбираем General, затем Font. В новом окне выбрать параметр Size и в окошке значений установить требуемый размер текста. По умолчанию стоит 13dp.
    </string>
    <string name="text_view_tips4">
        Изменение названия папки (Package)
        Такие изменения можно провести в несколько этапов:
        1. Внести изменения в файл манифеста - в AndroidManifest.xml
        2. Поменять название папки во всех файлах, в т.ч. в файле MainActivity.java, если в них есть ссылка на старое название папки
        3. В папке Java выделить старое название папки (Package), которое подлежит изменению. Затем нажимаем на значек "Настройки" (шестеренка). В открывшемся окне настроек напролтив параметра CompactMiddlePackage нужно убрать переключатель checkBox/
        В результате - составной путь (директорий), например: com.example.myApplication разкладывается на три самостоятельные папки и подпапки - com, example и myApplication.
        4. Выделяем нужную папку, например example, ПКМ, выбираем операцию Refactor, а в открывшемся меню - rename.
        5. В открывшимся окне вносим изменеие в названии папки.
    </string>
    <string name="text_view_tips5">
        Как выбрать цвет фона
        Использование цвета и палитры в Material Design
        Цветовая система Material Design помогает осмысленно применить цвет к пользовательскому интерфейсу. В этой системе вы выбираете основной и дополнительный цвета для представления вашего бренда. Затем темные и светлые варианты каждого цвета можно по-разному применить к пользовательскому интерфейсу.
        Цвета и тематика
        Цветовые темы призваны быть гармоничными, обеспечивать доступность текста и отличать элементы пользовательского интерфейса и поверхности друг от друга.
        В Инструмент палитры материального дизайна или доступны палитры Material Design 2014, которые помогут вам выбрать цвета.
    </string>
    <string name="text_view_tips6">
        Как выбрать шрифт текста
        Google добавили в Android поддержку шрифтов из своего каталога Google Fonts. В этой статье мы подробно рассмотрим, как можно это реализовать в своём приложении.
        Благодаря Google Fonts вы можете использовать тысячи самых разных шрифтов в своих приложениях. Более того, эта возможность теперь распространяется не только на Android O (API 26), но также на все устройства, начиная с API 14, благодаря использованию библиотеки поддержки.
        Использование загружаемых шрифтов несёт в себе следующие преимущества:
        уменьшение размера APK (вам не нужно включать в проект .ttf файлы со шрифтами);
        приложение на устройстве пользователя могут совместно использовать шрифты из одного источника, не раздувая хранилище избыточными файлами.
        Как это работает?
        Благодаря встроенной поддержке шрифтов, особенно подчёркивается второй пункт. Например, ниже представлена схема, по которой разные приложения могут пользоваться общими шрифтами.
        Добавить загружаемые шрифты в своё приложение можно двумя способами.
        Через Android Studio
        Чтобы добавить таким способом, перейдём на разметку с виджетом, шрифт которого нужно изменить. На вкладке Design нужно кликнуть по виджету, затем в свойствах найти fontFamily и выбрать More fonts…
        Откроется окно со списком всех шрифтов, доступных в Google Fonts, где можно выбрать любой понравившийся. Выберем шрифт Orbitron и нажмём ОК. Важно здесь выбрать именно Create downloable font, поскольку Add font to project просто добавит шрифт в проект, что противоречит текущей цели.
        После этого Android Studio сама создаст необходимые файлы. В папке res/font будет создан файл orbitron.xml, в папке res/values файлы preloaded_fonts.xml и font_certs.xml.
    </string>
    <string name="text_view_theory1">
        Структура Android приложения
        В общем случае, Android-приложение состоит из:
        Java-классов, являющихся подклассами основных классов из Android SDK (View, Activity, ContentProvider, Service, BroadcastReciever, Intent) и Java-классов, у которых нет родителей в Android SDK.
        Манифеста приложения
        Ресурсов наподобие строк, изображений и т.п.
        Файлов

        Java классы
        View — базовый класс для всех виджетов пользовательского интерфейса (GUI widgets). Интерфейс Android-приложения представляет собой дерево экземпляров наследников этого класса. Можно создать это дерево программно, но это неправильно. Пользовательский интерфейс определяется с помощью XML (файлы слоёв, layout files), а во время исполнения автоматически превращается (inflate, термин Android) в дерево соответствующих объектов.
        Класс Activity и его подклассы содержат логику, лежащую за пользовательским интерфейсом. При ближайшем рассмотрении этот класс соответствует ViewModel в архитектурном шаблоне Model-View-ViewModel (MVVM). Отношение между подклассом Activity и пользовательским интерфейсом — это отношение один к одному; обычно каждый подкласс Activity имеет только один связанный с ним слой пользовательского интерфейса, и наоборот. Activity имеет жизненный цикл.
        В течении жизненного цикла Activity может находиться в одном из трёх состояний:
        Активно и выполняется — этот пользовательский интерфейс находится на переднем плане (говоря технически — на вершине стека активити)
        Приостановлено — если данный интерфейс пользователя потерял фокус, но всё ещё видим. В таком состоянии никакой код не выполняется.
        Завершено — если интерфейс пользователя невидим. В таком состоянии код не выполняется.
        Код активити выполняется только когда соответствующий интерфейс пользователя видим и имеет фокус. Нет гарантии, что объект Activity и связанные с ним объекты находятся в памяти, когда активити приостановлено или завершено (очень важно помнить об этом; ранее мы уже обсуждали этот момент управления памятью в Android).
        Класс ContentProvider и его подклассы представляют model в архитектуре MVVM. В большинстве практических случаев это обёртка над базой данных SQLite с немного причудливым способом доступа на основе URI. Теоретически, никто не мешает разработчику создать ContentProvider на основе чего-то ещё, кроме базы данных. Тем не менее, существующий метод query() контент-провайдера возвращает объект Cursor, который крайне похож на JDBC ResultSet интерфейсом и тем, как он работает. Поэтому вряд ли кто-то усомнится, что настоящее назначение контент-провайдеров — инкапсулировать базу данных.
        Класс Service и его подклассы. Сервисы  могут выполняться даже когда процесс, в котором они работают, не на переднем плане. Так, если вы разрабатываете активити, выполняющее растянутую во времени операцию, которая должна завершиться даже работая в фоне, вы должны создать Service, реализующий эту операцию, и запустить его из Activity.
        Класс BroadcastReceiver и его подклассы представляют собой «подписчика» в механизме взаимодейтсвия издатель/подписчик, реализованном в архитектуре Android.

        Манифест Android
        Манифест Android — ещё одна важная часть Android-приложения. Идея была навеяна манифестами плагинов для Eclipse.
        Манифест Android представляет собой XML файл и выполняет несколько функций. Вот как их описывает Google:
        Определяет имя Java-пакета приложения. Имя пакета представляет собой уникальный идентификатор для приложения.
        Описывает компоненты приложения — активити, сервисы, броадкаст-ресиверы и контент-провайдеры. Определяет имена классов, реализующие каждый из компонентов и оглашает их возможности (например, какие Intent-сообщения они могут обрабатывать). Эти объявления позволяют системе Android знать, какие компоненты и при каких условиях могут быть запущены.
        Предопределяет процессы, которые будут содержать компоненты приложения.
        Объявляет разрешения, которые приложение должно иметь для доступа к защищённым частям API и взаимодействия с другими приложениями.
        Также объявляет разрешения, которые требуются для доступа к компонентам приложения.
        Перечисляет классы Instrumentation, которые предоставляют профайлинг и другую информацию во время работы приложения. Эти объявления присутствуют в манифесте только пока приложение разрабатывается и тестируется; они удаляются перед публикацией приложения.
        Объявляет минимальный уровень Android API, который требует приложение.
        Перечисляет библиотеки, с которыми приложение должно быть связано.

        Ресурсы
        Каждое современное GUI приложение в той или иной форме использует ресурсы. Android-приложения — не исключение. Они используют следующие типы ресурсов:
        Изображения
        Слои GUI (XML файлы)
        Объявления меню (XML файлы)
        Текстовые строки

        Файлы
        Android-приложение использует несколько разных типов файлов:
        Файлы «общего назначения»
        Файлы БД
        Файлы Opaque Binary Blob (OBB) (они представляют собой зашифрованную файловую систему, которая может быть монтирована для приложения)
        Закешированные файлы
    </string>
    <string name="text_view_theory2">
        Lifecycle Activity
        Жизненный цикл приложения в Android жёстко контролируется системой и зависит от нужд пользователя, доступных ресурсов и т. д. Например, пользователь хочет запустить браузер. Решение о запуске приложения принимает система. Хотя последнее слово и остаётся за системой, она подчиняется определённым заданным и логическим правилам, позволяющим определить, можно ли загрузить, приостановить приложение или прекратить его работу. Если в данный момент пользователь работает с определённым окном, система даёт приоритет соответствующему приложению. И наоборот, если окно невидимо и система решает, что работу приложения необходимо остановить, чтобы мобилизовать дополнительные ресурсы, будет прекращена работа приложения, имеющего более низкий приоритет. В Android ресурсы более ограниченны, поэтому Android более жёстко контролирует работу приложений.
        Основные методы жизненного цикла Android приложений:
        protected void onCreate()
        protected void onStart()
        protected void onRestart()
        protected void onResume()
        protected void onPause()
        protected void onStop()
        protected void onDestroy()
    </string>
    <string name="text_view_theory3">
        Ресурсы Android приложения
        Ресурсы - один из основных компонентов, с которыми вам придется работать очень часто. В Android принято держать некоторые объекты - изображения, строковые константы, цвета, анимацию, стили и т.п. за пределами исходного кода. Система поддерживает хранение ресурсов в отдельных файлах. Ресурсы легче поддерживать, обновлять, редактировать.
        Каждое приложение на Android содержит каталог для ресурсов res и каталог для активов assets. Реальное различие между ресурсами и активами заключается в следующем:
        информация в каталоге ресурсов будет доступна в приложении через класс R, который автоматически генерируется средой разработки. То есть хранение файлов и данных в ресурсах (в каталоге res) делает их легкодоступными для использования в коде программы;
        для чтения информации, помещенной в каталог активов assets (необработанный формат файла), необходимо использовать AssetManager для чтения файла как потока байтов.
        Android умеет динамически выбирать данные из дерева ресурсов, содержащие разные значения для разных конфигураций, языков и регионов. При запуске Android автоматически загрузит нужный ресурс, не требуя ни одной строчки кода.
        Ресурсы в Android являются декларативными. В основном ресурсы хранятся в виде XML-файлов в каталоге res с подкаталогами values, drawable-ldpi, drawable-mdpi, drawable-hdpi, layout, но также бывают и другие типы ресурсов.
        Для удобства система создает идентификаторы ресурсов и использует их в файле R.java (класс R, который содержит ссылки на все ресурсы проекта), что позволяет ссылаться на ресурсы внутри кода программы. Статический класс R генерируется на основе ваших заданных ресурсов и создается во время компиляции проекта. При создании класс содержит статические подклассы для всех типов ресурсов, для которых был описан хотя бы один экземпляр. Подробнее о классе R рассказано ниже.
        Так как файл R генерируется автоматически, то не смысла его редактировать вручную, потому что все изменения будут утеряны при повторной генерации.
        В общем виде ресурсы представляют собой файл (например, изображение) или значение (например, заголовок программы), связанные с создаваемым приложением. Удобств использования ресурсов заключается в том, что их можно изменять без повторной компиляции или новой разработки приложения. Имена файлов для ресурсов должны состоять исключительно из букв в нижнем регистре, чисел и символов подчёркивания.
        Самыми распространёнными ресурсами являются, пожалуй, строки (string), цвета (color) и графические рисунки (bitmap). В приложении не рекомендуется применять жёстко написанные строки кода - вместо них следует использовать соответствующие идентификаторы, что позволяет изменять текст строкового ресурса, не изменяя исходного кода.
        Начинающие программисты не всегда до конца правильно понимают процесс создания ресурсов. В Android используются два подхода - первый подход заключается в том, что ресурсы задаются в файле, при этом имя файла значения не имеет. Второй подход - ресурс задаётся в виде самого файла, и тогда имя файла уже имеет значение (при этом нужно учитывать определённые нюансы).
    </string>
    <string name="text_view_theory4">
        Material Design
        Material design - это язык визуальных образов, который не так давно создала корпорация Google для унификации интерфейсов всех ее продуктов и сервисов. Брендбук , который включает в себя все элементы данного направления в дизайне, постоянно развивается и дополняется, при этом сохраняя фундаментальные основы неизменными.
        Material Design (Материальный дизайн) — дизайн программного обеспечения и приложений операционной системы Android от компании Google. Впервые представлен на конференции Google I/O 25 июня 2014 года. Идея дизайна заключается в приложениях, которые открываются и сворачиваются как карточки, используя эффекты теней. По идее дизайнеров Google, у приложений не должно быть острых углов, карточки должны переключаться между собой плавно и практически незаметно.
        Изначально внутри компании его называли кодовым именем «квантовая бумага» (quantum paper). Основная метафора материального дизайна — плоская бумага, находящаяся в трехмерном пространстве.
        В основе Material Design лежат четыре принципа:
        1. Тактильные поверхности
        Все элементы интерфейса — это слои цифровой бумаги. Они располагаются на разной высоте и отбрасывают тени. Это помогает пользователям отличить главные элементы от второстепенных и делает интерфейс интуитивно понятным.
        2. Полиграфический дизайн
        Логично, что на цифровой бумаге нужно писать цифровыми чернилами. Все, что изображено и написано на слоях-элементах, подчиняется законам печатного дизайна. Так можно акцентировать внимание пользователя на нужном элементе и обозначить иерархию интерфейса.
        3. Осознанная анимация
        Все элементы, которые есть на экране, не могут просто так появляться и исчезать, — ведь в реальной жизни так не бывает. Объекты плавно переходят один в другой и подсказывают пользователю, как работает интерфейс.
        4. Адаптивный дизайн
        Все вышеперечисленное должно работать на любых устройствах.
    </string>
    <string name="text_view_theory5">
        Интенты
        Намерение (Intent) - это механизм для описания одной операции - выбрать фотографию, отправить письмо, сделать звонок, запустить браузер и перейти по указанному адресу. В Android-приложениях многие операции работают через намерения.
        Наиболее распространённый сценарий использования намерения - запуск другой активности в своём приложении. Об этом можно почитать в соответствующем уроке.
        Но это не единственный вариант использования намерения. Также можно использовать для объявления о запуске активности или сервиса, направленных на выполнение каких-либо действий (как правило, речь о работе с определенной частью данных) или для передачи уведомлений о том, что произошло некое событие (или действие).
        Намерения могут применяться для трансляции сообщений по системе. Любое приложение способно зарегистрировать широковещательный приёмник и отслеживать эти намерения с возможностью на них реагировать. Это позволяет создавать приложения, использующие событийную модель, в основе которой лежат внутренние, системные или сторонние события, передаваемые внешними программами.
        Android транслирует намерения для объявления о системных событиях, например об изменениях в состоянии сетевого подключения или в уровне заряда батареи. Системные приложения в Android, такие как программы дозвона или управления SMS, регистрируют компоненты, отслеживающие заданные намерения, например входящий звонок или получено новое SMS-сообщение, и соответствующим образом реагируют на них.
        Явные намерения
        Вспомним код для перехода на вторую активность в своём приложении:
        Intent intent = new Intent(HelloWorld.this, AboutActivity.class);
        startActivity(intent);
        В намерении мы явно указали имя класса активности во втором параметре. Данный класс у нас прописан в манифесте, и система, просматривая манифест, запустит нужную активность. Вот почему у нас сначала программа завершалась с ошибкой. Когда мы создали класс, но не прописали его в манифесте, то система не понимала, чего от неё хотят.
        Первый параметр – это Context. Активность является подклассом Context, поэтому мы можем использовать её как HelloWorld.this, или укороченную запись this.
        Таким образом, ваше приложение может иметь десять активностей, и вы можете вызвать любую из них, зная её имя класса. Это явный вызов, где вы явно указываете имя класса для запуска.
        После вызова метода создастся новая активность, которая запустится или возобновит свою работу, переместившись на вершину стека активностей.
        Также при переходе на другую активность мы можем указать какие-то данные, а принимающая активность должна уметь обработать их. Для этих целей существуют методы типа putXXX(). Например, для передачи списка файлов из одной активности в другую:
        // У первой активности
<!--        ArrayList<File> fileList = new ArrayList<File>();-->
<!--        Intent intent = new Intent(MainActivity.this, SecondActivity.class);-->
<!--        intent.putExtra("FILES_LIST", fileList);-->
<!--        startActivity(intent);-->
        // У второй активности
<!--        ArrayList<File> filelist = (ArrayList<File>)getIntent().getSerializableExtra("FILES_LIST");-->
        Неявные намерения
        Существует также неявный вызов активности. В этом случае при создании намерения мы используем не имя класса, а указываем параметры action, data, category с определёнными значениями. Система анализирует, что мы тут такого понаписали и начинает подбирать подходящий вариант для запуска.
        Если параметры намерения совпадают с условиями нашего фильтра, то наше приложение (активность) будет вызвано. Система сканирует активности всех установленных приложений, и если находится несколько подходящих активностей, то Android предоставляет пользователю выбор, какой именно программой следует воспользоваться. Если найдётся только одна подходящая активность, то, естественно, никакого диалога для выбора не будет, и активность запустится автоматически.
        Неявные намерения — это механизм, позволяющий запрашивать анонимные компоненты приложений с помощью действий. Вы можете попросить систему запустить активность, выполняющую заданное действие, не зная ничего ни о самой активности, ни о её приложении. Например, мы указываем телефонный номер, но понятия не имеем, как программой дозвона пользуется пользователь на своём телефоне. Но это уже не наша проблема, пусть пользователь сам выбирает, как ему звонить по номеру, который мы можем ему предоставить.
      </string>
    <string name="text_view_theory6">
        Адаптеры
        В Android часто используются адаптеры. Если говорить в общих чертах, то адаптеры упрощают связывание данных с элементом управления. Адаптеры используются при работе с виджетами, которые дополняют android.widget.AdapterView: ListView, ExpandableListView, GridView, Spinner, Gallery, а также в активности ListActivity и др. Сам AdapterView дополняет android.widget.ViewGroup.
        Итак, у нас есть набор объектов и есть компонент View. Назначение адаптера заключается в том, чтобы предоставлять дочерние виды для контейнера. Адаптер берет данные и метаданные определенного контейнера и строит каждый дочерний вид. Например, мы формируем пункты списка (массив строк) и передаём его списку ListView.
        Что такое вообще адаптер? Это переходник между двумя какими-то предметами. Допустим, между питьевой водой и стаканом требуется адаптер в виде крана.
        В приложениях очень часто используется список на основе ListView. Сам список состоит из множества элементов TextView, которые идут друг за другом. Но их количество будет зависеть от того, чтобы мы хотим отобразить. Если нам нужны дни недели, то достаточно семи элементов, если месяцы, то уже двенадцать, ну а если нам нужны имена котов в Кот д&amp;#39Ивуаре, то счёт пойдет на сотни. Короче говоря, нам нужно составить данные, например, в виде массива и скормить его списку. Адаптер этим и занимается. Он берёт по порядку предоставленные данные и размещает их в списке по порядку. При этом адаптер на лету создаёт нужные компоненты TextView и помещает в него приготовленный текст. Данные могут быть находиться не только в массиве, но и в базе данных. Для такого случая используется другой адаптер. А также вы можете придумать свой адаптер. Существуют уже готовые адаптеры на самые распространённые случаи и их предназначение можно определить по именам. Например, ArrayAdapter использует массив, а CursorAdapter работает с объектом Cursor, используемый в базах данных.
        Готовые адаптеры
        Все адаптеры, содержащиеся в Android, дополняют базовый адаптер BaseAdapter. Вот список готовых адаптеров:
        ArrayAdapter &amp;lt T &amp;gt предназначен для работы с ListView. Данные представлены в виде массива, которые размещаются в отдельных элементах TextView
        ListAdapter - адаптер между ListView и данными. Строго говоря, это класс-интерфейс, который можно использовать и в ArrayAdapter и в SimpleAdapter и т.д.
        SpinnerAdapter - адаптер для связки данных с элементом Spinner. Это тоже интерфейс, как ListAdapter и работает по схожему принципу
        SimpleAdapter - адаптер, позволяющий заполнить данными список более сложной структуры, например, два текста в одной строке списка.
        SimpleCursorAdapter - дополняет ResourceCursorAdapter и создаёт компоненты TextView/ImageView из столбцов, содержащихся в курсоре. Компоненты определяются в ресурсах
        CursorAdapter - предназначен для работы с ListView, предоставляет данные для списка через курсор, который должен иметь колонку с именем "_id"
        ResourceCursorAdapter - этот адаптер дополняет CursorAdapter и может создавать виды из ресурсов
        HeaderViewListAdapter - расширенный вариант ListAdapter, когда ListView имеет заголовки.
        WrapperListAdapter - еще один адаптер для списков.

        BaseAdapter
        Стандартные адаптеры не всегда покрывают потребности программиста. Если вам нужен свой собственный адаптер, то в Android есть абстрактный класс BaseAdapter, который можно расширить. Собственный адаптер необходим в тех случаях, когда требуется специальное управление данными или дополнительный контроль над отображением дочерних представлений. Кроме того, вы можете предусмотреть в своём адаптере элементы кэширования для повышения производительности работы.
        Пример использования адаптере на основе BaseAdapter можно увидеть при создании GridView с картинками и в других примерах.
        У BaseAdapter есть несколько методов, которые следует переопределить. Например, метод getCount() позволяет узнать количество выводимых объектов.
        Другой важный метод адаптера — getView(), который отвечает за создание отдельных элементов списка. Он вызывается для каждого элемента списка, чтобы определить, какие данные нужно отобразить. Метод getVew() содержит параметр convertView, который позволяет использовать заново уже существующий элемент списка, который не отображается, т.к. пользователь пролистнул его с видимой части дисплея. Если convertView не пустой, он может быть использован заново, чтобы не грузить разметку списка. Подобный подход способствует увеличению производительности.
        Метод getView() возвращает View, который фактически является контейнером ViewGroup и содержит в себе другие компоненты, например, ImageView или TextView.
    </string>

    <string name="picture1">TODO</string>
</resources>